/* ================= STATE ================= */

let tension = 0;
let tensionSinceLastWE = 0;
let presence = 0;
let harmonic = 0;
let convergence = 0;
let breach = 0;
let logEntries = [];

/* ================= EVENT POOL ================= */

const worldEventPools = {
  act1: [
    {
      title: "The World Anchor",
      text: "A titanic spike of stone plunges endlessly downward.",
      options: [
        { label: "Reinforce", tag: "Order", effect: "All factions gain 1 Relic." },
        { label: "Damage", tag: "Profit", effect: "Spawn a World Boss." }
      ]
    }
  ]
};

/* ================= EVENT SYSTEM ================= */

function drawWorldEvent() {
  let pool = worldEventPools.act1;
  let event = pool[Math.floor(Math.random() * pool.length)];
  openEventModal(event);
}

function openEventModal(event) {
  document.getElementById("eventTitle").textContent = event.title;
  document.getElementById("eventText").textContent = event.text;

  let container = document.getElementById("eventOptions");
  container.innerHTML = "";

  event.options.forEach(o => {
    let btn = document.createElement("button");
    btn.innerHTML = `<strong>${o.label}</strong><br><small>${o.tag}</small>`;
    btn.onclick = () => {
      container.innerHTML = `
        <h3>Outcome</h3>
        <p>${o.effect}</p>
        <button onclick="closeModal()">Continue</button>
      `;
      addLog(event.title + " — " + o.tag);
    };
    container.appendChild(btn);
  });

  document.getElementById("eventModal").style.display = "flex";
}

function closeModal() {
  document.getElementById("eventModal").style.display = "none";
}

/* ================= WORLD TENSION ================= */

function increaseTension() {
  tension++;
  tensionSinceLastWE++;
  document.getElementById("tensionValue").textContent = tension;

  let box = document.createElement("div");
  box.className = "tensionBox";
  document.getElementById("tensionRow").appendChild(box);

  if (tensionSinceLastWE >= 4) {
    tensionSinceLastWE = 0;
    drawWorldEvent();
  }
}

function decreaseTension() {
  if (tension <= 0) return;
  tension--;
  document.getElementById("tensionValue").textContent = tension;

  let row = document.getElementById("tensionRow");
  if (row.lastChild) row.removeChild(row.lastChild);
}

function resetTension() {
  tension = 0;
  tensionSinceLastWE = 0;
  document.getElementById("tensionValue").textContent = 0;
  document.getElementById("tensionRow").innerHTML = "";
}

/* ================= PRESENCE ================= */

function changePresence(v) {
  presence += v;
  if (presence < 0) presence = 0;

  document.getElementById("presenceValue").textContent = presence;
  document.getElementById("presenceFill").style.width =
    Math.min((presence / 15) * 100, 100) + "%";

  let tier = "Dormant (0–2)";
  if (presence >= 3) tier = "Stirring (3–4)";
  if (presence >= 5) tier = "Unstable (5–6)";
  if (presence >= 7) tier = "Hostile (7–8)";
  if (presence >= 9) tier = "Critical (9–10)";
  if (presence >= 11) tier = "Cataclysm (11+)";

  document.getElementById("presenceTier").textContent = tier;
}

/* ================= HARMONIC ================= */

function changeHarmonic(v) {
  harmonic += v;
  if (harmonic < 0) harmonic = 0;

  document.getElementById("harmonicValue").textContent = harmonic;
  document.getElementById("harmonicFill").style.width =
    Math.min((harmonic / 12) * 100, 100) + "%";

  let tier = "Quiet";
  if (harmonic >= 2) tier = "Vibrating";
  if (harmonic >= 5) tier = "Surging";
  if (harmonic >= 7) tier = "Overtuned";
  if (harmonic >= 10) tier = "Resonant Collapse";

  document.getElementById("harmonicTier").textContent = tier;
}

/* ================= CONVERGENCE ================= */

function changeConvergence(v) {
  convergence += v;
  if (convergence < 0) convergence = 0;

  document.getElementById("convergenceValue").textContent = convergence;
  document.getElementById("convergenceFill").style.width =
    Math.min((convergence / 12) * 100, 100) + "%";

  let tier = "Subtle";
  if (convergence >= 3) tier = "Gathering";
  if (convergence >= 5) tier = "Distorted";
  if (convergence >= 8) tier = "Aligned";
  if (convergence >= 10) tier = "Manifest";

  document.getElementById("convergenceTier").textContent = tier;
}

/* ================= BREACH ================= */

function increaseBreach() {
  breach++;
  document.getElementById("breachValue").textContent = breach;

  let box = document.createElement("div");
  box.className = "breachBox";
  document.getElementById("breachRow").appendChild(box);
}

function decreaseBreach() {
  if (breach <= 0) return;
  breach--;
  document.getElementById("breachValue").textContent = breach;

  let row = document.getElementById("breachRow");
  if (row.lastChild) row.removeChild(row.lastChild);
}

function resetBreach() {
  breach = 0;
  document.getElementById("breachValue").textContent = 0;
  document.getElementById("breachRow").innerHTML = "";
}

/* ================= LOG ================= */

function addLog(msg) {
  let time = new Date().toLocaleTimeString();
  logEntries.unshift("[" + time + "] " + msg);
  renderLog();
}

function renderLog() {
  let c = document.getElementById("logContainer");
  c.innerHTML = "";
  logEntries.forEach(e => {
    let d = document.createElement("div");
    d.textContent = e;
    c.appendChild(d);
  });
}

function clearLog() {
  logEntries = [];
  renderLog();
}
